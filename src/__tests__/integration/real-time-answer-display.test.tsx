/**\n * Comprehensive Integration Test for Real-time Answer Display System\n * \n * Tests the complete pipeline from question detection to real-time answer display,\n * including WebSocket communication, performance monitoring, and error handling.\n */\n\nimport { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals'\nimport { RealTimeAnswerDisplay } from '../src/components/RealTimeAnswerDisplay'\nimport { AnswerDisplayManager } from '../src/services/AnswerDisplayManager'\nimport { AnswerStreamingManager } from '../src/services/AnswerStreamingManager'\nimport { UltraFastWebSocketManager } from '../src/services/UltraFastWebSocketManager'\nimport EnhancedWebSocketManager from '../src/services/EnhancedWebSocketManager'\nimport useWebSocketOptimized from '../src/hooks/useWebSocketOptimized'\nimport { usePerformanceMonitor } from '../src/hooks/usePerformanceMonitor'\nimport { AnswerDisplayErrorBoundary } from '../src/components/AnswerDisplayErrorBoundary'\nimport React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport '@testing-library/jest-dom'\n\n// Mock WebSocket\nclass MockWebSocket {\n  readyState = 1 // OPEN\n  onopen: ((event: Event) => void) | null = null\n  onmessage: ((event: MessageEvent) => void) | null = null\n  onclose: ((event: CloseEvent) => void) | null = null\n  onerror: ((event: Event) => void) | null = null\n  \n  messages: any[] = []\n  \n  constructor(url: string) {\n    setTimeout(() => {\n      this.onopen?.(new Event('open'))\n    }, 10)\n  }\n  \n  send(data: string) {\n    this.messages.push(JSON.parse(data))\n  }\n  \n  close() {\n    setTimeout(() => {\n      this.onclose?.(new CloseEvent('close', { code: 1000 }))\n    }, 10)\n  }\n  \n  // Test helpers\n  simulateMessage(data: any) {\n    this.onmessage?.(new MessageEvent('message', { data: JSON.stringify(data) }))\n  }\n  \n  simulateError() {\n    this.onerror?.(new Event('error'))\n  }\n}\n\n// Mock global WebSocket\nglobal.WebSocket = MockWebSocket as any\n\ndescribe('Real-time Answer Display System Integration', () => {\n  let mockWebSocket: MockWebSocket\n  let displayManager: AnswerDisplayManager\n  let streamingManager: AnswerStreamingManager\n  let webSocketManager: UltraFastWebSocketManager\n  \n  beforeAll(() => {\n    // Setup test environment\n    process.env.REACT_APP_WEBSOCKET_URL = 'ws://localhost:8080'\n  })\n  \n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks()\n    \n    // Create fresh instances for each test\n    webSocketManager = new UltraFastWebSocketManager({\n      maxConnections: 1,\n      heartbeatInterval: 1000\n    })\n    \n    streamingManager = new AnswerStreamingManager(webSocketManager, {\n      streamingMode: 'character',\n      maxConcurrentStreams: 1\n    })\n    \n    displayManager = new AnswerDisplayManager(\n      streamingManager,\n      webSocketManager,\n      {\n        enableTypewriterEffect: true,\n        typewriterSpeed: 50,\n        showSearchProgress: true,\n        enableDebugLogging: false\n      }\n    )\n  })\n  \n  afterEach(() => {\n    // Cleanup\n    displayManager?.destroy()\n    streamingManager?.destroy()\n    mockWebSocket?.close()\n  })\n  \n  describe('WebSocket Connection and Communication', () => {\n    test('should establish WebSocket connection successfully', async () => {\n      const TestComponent = () => {\n        const webSocketOptimized = useWebSocketOptimized({\n          url: 'ws://localhost:8080',\n          enableAutoOptimization: true\n        })\n        \n        React.useEffect(() => {\n          webSocketOptimized.connect()\n        }, [])\n        \n        return (\n          <div data-testid=\"connection-status\">\n            {webSocketOptimized.isConnected ? 'Connected' : 'Disconnected'}\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('connection-status')).toHaveTextContent('Connected')\n      })\n    })\n    \n    test('should handle WebSocket reconnection on failure', async () => {\n      const TestComponent = () => {\n        const webSocketOptimized = useWebSocketOptimized({\n          url: 'ws://localhost:8080',\n          maxReconnectAttempts: 3,\n          reconnectInterval: 100\n        })\n        \n        React.useEffect(() => {\n          webSocketOptimized.connect()\n        }, [])\n        \n        return (\n          <div>\n            <div data-testid=\"connection-status\">\n              {webSocketOptimized.connectionState.status}\n            </div>\n            <div data-testid=\"reconnect-count\">\n              {webSocketOptimized.connectionState.reconnectCount}\n            </div>\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('connection-status')).toHaveTextContent('connected')\n      })\n      \n      // Simulate connection failure\n      const wsInstance = (global.WebSocket as any).mock.instances[0]\n      wsInstance.simulateError()\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('connection-status')).toHaveTextContent('reconnecting')\n      })\n    })\n    \n    test('should send and receive messages correctly', async () => {\n      const enhancedWebSocket = new EnhancedWebSocketManager({\n        url: 'ws://localhost:8080',\n        maxReconnectAttempts: 1\n      })\n      \n      await enhancedWebSocket.connect()\n      \n      const messagePromise = new Promise(resolve => {\n        enhancedWebSocket.on('message', resolve)\n      })\n      \n      // Send test message\n      await enhancedWebSocket.sendMessage('test', { data: 'hello world' })\n      \n      // Simulate received message\n      const wsInstance = (global.WebSocket as any).mock.instances[0] as MockWebSocket\n      wsInstance.simulateMessage({\n        id: 'test-response',\n        type: 'response',\n        data: 'response data'\n      })\n      \n      const receivedMessage = await messagePromise\n      expect(receivedMessage).toMatchObject({\n        type: 'response',\n        data: 'response data'\n      })\n    })\n  })\n  \n  describe('Answer Display Pipeline', () => {\n    test('should start answer display and show initial state', async () => {\n      const onAnswerComplete = jest.fn()\n      const onSearchStateChange = jest.fn()\n      \n      render(\n        <AnswerDisplayErrorBoundary>\n          <RealTimeAnswerDisplay\n            show={true}\n            question=\"What is the capital of France?\"\n            onAnswerComplete={onAnswerComplete}\n            onSearchStateChange={onSearchStateChange}\n            showDebug={true}\n          />\n        </AnswerDisplayErrorBoundary>\n      )\n      \n      // Check initial render\n      expect(screen.getByTestId('answer-display')).toBeInTheDocument()\n      expect(screen.getByText(/searching/i)).toBeInTheDocument()\n    })\n    \n    test('should handle partial answer updates', async () => {\n      const TestComponent = () => {\n        const [currentDisplay, setCurrentDisplay] = React.useState(null)\n        \n        React.useEffect(() => {\n          const displayManager = new AnswerDisplayManager(\n            streamingManager,\n            webSocketManager\n          )\n          \n          displayManager.on('partial-answer-updated', (display) => {\n            setCurrentDisplay(display)\n          })\n          \n          displayManager.startAnswerDisplay('test-q1', 'Test question')\n          \n          // Simulate partial updates\n          setTimeout(() => {\n            displayManager.updatePartialAnswer('test-q1', 'The capital')\n          }, 100)\n          \n          setTimeout(() => {\n            displayManager.updatePartialAnswer('test-q1', 'The capital of France')\n          }, 200)\n          \n          setTimeout(() => {\n            displayManager.completeAnswer('test-q1', 'The capital of France is Paris.', {\n              confidence: 0.95,\n              sources: [{ url: 'example.com', title: 'Test Source' }]\n            })\n          }, 300)\n          \n          return () => displayManager.destroy()\n        }, [])\n        \n        return (\n          <div data-testid=\"answer-text\">\n            {currentDisplay?.answerText || 'No answer yet'}\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      // Check progression of partial updates\n      await waitFor(() => {\n        expect(screen.getByTestId('answer-text')).toHaveTextContent('The capital')\n      })\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('answer-text')).toHaveTextContent('The capital of France')\n      })\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('answer-text')).toHaveTextContent('The capital of France is Paris.')\n      })\n    })\n    \n    test('should handle search state updates', async () => {\n      const onSearchStateChange = jest.fn()\n      \n      render(\n        <RealTimeAnswerDisplay\n          show={true}\n          question=\"Test question\"\n          onSearchStateChange={onSearchStateChange}\n        />\n      )\n      \n      // Simulate search state updates\n      await waitFor(() => {\n        expect(onSearchStateChange).toHaveBeenCalled()\n      })\n    })\n  })\n  \n  describe('Performance Monitoring', () => {\n    test('should track performance metrics', async () => {\n      const TestComponent = () => {\n        const performanceMonitor = usePerformanceMonitor({\n          enableMemoryMonitoring: true,\n          enableWebSocketMonitoring: true\n        })\n        \n        React.useEffect(() => {\n          performanceMonitor.startMonitoring({\n            componentName: 'TestComponent'\n          })\n        }, [])\n        \n        const metrics = performanceMonitor.getMetrics()\n        \n        return (\n          <div>\n            <div data-testid=\"memory-usage\">{metrics.memoryUsage}</div>\n            <div data-testid=\"render-time\">{metrics.renderTime || 0}</div>\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        const memoryElement = screen.getByTestId('memory-usage')\n        expect(memoryElement.textContent).not.toBe('0')\n      })\n    })\n    \n    test('should detect performance issues and generate alerts', async () => {\n      const onPerformanceAlert = jest.fn()\n      \n      const TestComponent = () => {\n        const performanceMonitor = usePerformanceMonitor({\n          enableMemoryMonitoring: true,\n          alertThresholds: {\n            memoryUsage: 1, // Very low threshold for testing\n            latency: 100,\n            errorRate: 0.01\n          }\n        })\n        \n        React.useEffect(() => {\n          performanceMonitor.startMonitoring({\n            componentName: 'TestComponent'\n          })\n          \n          // Force a performance alert by exceeding memory threshold\n          performanceMonitor.recordMemoryUsage(1000000) // 1MB\n        }, [])\n        \n        return <div>Performance Test</div>\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        // Should have generated a memory alert\n        expect(onPerformanceAlert).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'memory',\n            severity: expect.any(String)\n          })\n        )\n      })\n    })\n  })\n  \n  describe('Error Handling and Recovery', () => {\n    test('should handle WebSocket connection errors gracefully', async () => {\n      const TestComponent = () => {\n        const webSocketOptimized = useWebSocketOptimized({\n          url: 'ws://invalid-url',\n          maxReconnectAttempts: 1,\n          reconnectInterval: 100\n        })\n        \n        React.useEffect(() => {\n          webSocketOptimized.connect().catch(() => {})\n        }, [])\n        \n        return (\n          <div data-testid=\"connection-state\">\n            {webSocketOptimized.connectionState.status}\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('connection-state')).toHaveTextContent('error')\n      })\n    })\n    \n    test('should recover from component errors with error boundary', () => {\n      const ThrowingComponent = () => {\n        throw new Error('Test error')\n      }\n      \n      const onRetry = jest.fn()\n      \n      render(\n        <AnswerDisplayErrorBoundary onRetry={onRetry} showTechnicalDetails={true}>\n          <ThrowingComponent />\n        </AnswerDisplayErrorBoundary>\n      )\n      \n      // Error boundary should catch the error\n      expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()\n      expect(screen.getByText(/try again/i)).toBeInTheDocument()\n      \n      // Test retry functionality\n      fireEvent.click(screen.getByText(/try again/i))\n      expect(onRetry).toHaveBeenCalled()\n    })\n  })\n  \n  describe('Integration Scenarios', () => {\n    test('should handle complete question-answer flow', async () => {\n      const onAnswerComplete = jest.fn()\n      \n      render(\n        <AnswerDisplayErrorBoundary>\n          <RealTimeAnswerDisplay\n            show={true}\n            question=\"What is React?\"\n            onAnswerComplete={onAnswerComplete}\n            showDebug={true}\n            config={{\n              enableTypewriterEffect: true,\n              typewriterSpeed: 100,\n              showSearchProgress: true\n            }}\n          />\n        </AnswerDisplayErrorBoundary>\n      )\n      \n      // Should show initial loading state\n      await waitFor(() => {\n        expect(screen.getByRole('region', { name: /real-time ai answer display/i })).toBeInTheDocument()\n      })\n      \n      // Simulate answer completion\n      setTimeout(() => {\n        const mockAnswer = {\n          id: 'test-answer',\n          questionId: 'test-q',\n          questionText: 'What is React?',\n          answerText: 'React is a JavaScript library for building user interfaces.',\n          isPartial: false,\n          isComplete: true,\n          confidence: 0.9,\n          sources: [\n            {\n              url: 'https://reactjs.org',\n              title: 'React Official Documentation',\n              snippet: 'A JavaScript library for building user interfaces',\n              credibilityScore: 1.0\n            }\n          ],\n          timestamp: Date.now()\n        }\n        \n        onAnswerComplete(mockAnswer)\n      }, 100)\n      \n      await waitFor(() => {\n        expect(onAnswerComplete).toHaveBeenCalled()\n      })\n    })\n    \n    test('should handle multiple concurrent questions', async () => {\n      const questions = [\n        'What is TypeScript?',\n        'What is Node.js?',\n        'What is GraphQL?'\n      ]\n      \n      const TestComponent = () => {\n        const [activeQuestions, setActiveQuestions] = React.useState<string[]>([])\n        \n        React.useEffect(() => {\n          // Start all questions simultaneously\n          setActiveQuestions(questions)\n        }, [])\n        \n        return (\n          <div>\n            {activeQuestions.map((question, index) => (\n              <RealTimeAnswerDisplay\n                key={index}\n                show={true}\n                question={question}\n                compact={true}\n                onAnswerComplete={(answer) => {\n                  console.log(`Answer completed for: ${answer.questionText}`)\n                }}\n              />\n            ))}\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      // Should render all question displays\n      await waitFor(() => {\n        questions.forEach(question => {\n          expect(screen.getByText(new RegExp(question.slice(0, 20), 'i'))).toBeInTheDocument()\n        })\n      })\n    })\n    \n    test('should maintain performance under load', async () => {\n      const startTime = performance.now()\n      const messageCount = 100\n      \n      const TestComponent = () => {\n        const [messages, setMessages] = React.useState<any[]>([])\n        const webSocketOptimized = useWebSocketOptimized({\n          url: 'ws://localhost:8080',\n          enableAutoOptimization: true\n        })\n        \n        React.useEffect(() => {\n          webSocketOptimized.connect().then(() => {\n            // Send multiple messages rapidly\n            for (let i = 0; i < messageCount; i++) {\n              webSocketOptimized.sendMessage('test', { \n                index: i, \n                timestamp: Date.now() \n              })\n            }\n          })\n        }, [])\n        \n        React.useEffect(() => {\n          if (webSocketOptimized.lastMessage) {\n            setMessages(prev => [...prev, webSocketOptimized.lastMessage])\n          }\n        }, [webSocketOptimized.lastMessage])\n        \n        const metrics = webSocketOptimized.metrics\n        \n        return (\n          <div>\n            <div data-testid=\"message-count\">{messages.length}</div>\n            <div data-testid=\"performance-score\">\n              {metrics?.overallPerformance ? (metrics.overallPerformance * 100).toFixed(1) : '0'}\n            </div>\n          </div>\n        )\n      }\n      \n      render(<TestComponent />)\n      \n      await waitFor(() => {\n        const performanceScore = screen.getByTestId('performance-score')\n        const score = parseFloat(performanceScore.textContent || '0')\n        expect(score).toBeGreaterThan(50) // At least 50% performance\n      }, { timeout: 5000 })\n      \n      const endTime = performance.now()\n      const totalTime = endTime - startTime\n      \n      // Should complete within reasonable time\n      expect(totalTime).toBeLessThan(3000) // 3 seconds\n    })\n  })\n  \n  describe('Memory Management and Cleanup', () => {\n    test('should properly cleanup resources on unmount', () => {\n      const TestComponent = ({ mounted }: { mounted: boolean }) => {\n        if (!mounted) return null\n        \n        return (\n          <RealTimeAnswerDisplay\n            show={true}\n            question=\"Test question\"\n            showDebug={true}\n          />\n        )\n      }\n      \n      const { rerender } = render(<TestComponent mounted={true} />)\n      \n      // Should be mounted\n      expect(screen.getByTestId('answer-display')).toBeInTheDocument()\n      \n      // Unmount component\n      rerender(<TestComponent mounted={false} />)\n      \n      // Should be cleaned up\n      expect(screen.queryByTestId('answer-display')).not.toBeInTheDocument()\n    })\n  })\n})\n\n// Additional test utilities\nexport const createMockAnswerDisplay = (overrides = {}) => ({\n  id: 'mock-answer-id',\n  questionId: 'mock-question-id',\n  questionText: 'Mock question?',\n  answerText: 'Mock answer text',\n  isPartial: false,\n  isComplete: true,\n  confidence: 0.85,\n  sources: [\n    {\n      url: 'https://example.com',\n      title: 'Example Source',\n      snippet: 'Example snippet',\n      credibilityScore: 0.9\n    }\n  ],\n  timestamp: Date.now(),\n  ...overrides\n})\n\nexport const createMockSearchState = (overrides = {}) => ({\n  isSearching: true,\n  progress: 45,\n  currentSource: 'Example API',\n  sourcesFound: 3,\n  totalSources: 5,\n  estimatedTimeRemaining: 2000,\n  ...overrides\n})\n\nexport const simulateTypingEffect = async (element: HTMLElement, text: string, speed = 50) => {\n  for (let i = 0; i <= text.length; i++) {\n    const partialText = text.substring(0, i)\n    element.textContent = partialText\n    await new Promise(resolve => setTimeout(resolve, speed))\n  }\n}