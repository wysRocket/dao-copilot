#!/usr/bin/env node
/**
 * v1beta Configuration Migration Script
 *
 * This script helps users migrate their existing configuration to use the new
 * v1beta Gemini Live API with improved performance and reliability.
 */

import * as fs from 'fs'
import * as path from 'path'
import {migrateLegacyEnvironment, migrateToV1Beta} from '../services/transcription-compatibility'
import {createOptimizedV1BetaConfig, getConfigSummary} from '../helpers/gemini-websocket-config'

interface MigrationOptions {
  dryRun?: boolean
  backup?: boolean
  verbose?: boolean
}

/**
 * Find and parse existing .env file
 */
function parseExistingEnvFile(envPath: string): Record<string, string> {
  const envConfig: Record<string, string> = {}

  if (!fs.existsSync(envPath)) {
    return envConfig
  }

  const envContent = fs.readFileSync(envPath, 'utf8')

  for (const line of envContent.split('\n')) {
    const trimmedLine = line.trim()
    if (trimmedLine && !trimmedLine.startsWith('#')) {
      const [key, ...valueParts] = trimmedLine.split('=')
      if (key && valueParts.length > 0) {
        envConfig[key.trim()] = valueParts.join('=').replace(/^["']|["']$/g, '')
      }
    }
  }

  return envConfig
}

/**
 * Generate updated .env content with v1beta settings
 */
function generateUpdatedEnvContent(currentEnv: Record<string, string>): string {
  const migration = migrateLegacyEnvironment()
  const updatedEnv = {...currentEnv, ...migration.migrated}

  // Apply v1beta optimizations
  updatedEnv.GEMINI_MODEL_NAME = 'gemini-live-2.5-flash-preview'
  updatedEnv.GEMINI_API_VERSION = 'v1beta'
  updatedEnv.GEMINI_USE_V1BETA = 'true'

  // Ensure optimal settings
  if (!updatedEnv.GEMINI_TRANSCRIPTION_MODE) {
    updatedEnv.GEMINI_TRANSCRIPTION_MODE = 'hybrid'
  }
  if (!updatedEnv.GEMINI_FALLBACK_TO_BATCH) {
    updatedEnv.GEMINI_FALLBACK_TO_BATCH = 'true'
  }

  let content = '# Gemini Live API Configuration (v1beta optimized)\n'
  content += '# Generated by v1beta migration script\n\n'

  // Group related settings
  const groups = {
    'API Keys': ['GOOGLE_API_KEY', 'GEMINI_API_KEY', 'ANTHROPIC_API_KEY', 'OPENAI_API_KEY'],
    'v1beta Model Configuration': ['GEMINI_MODEL_NAME', 'GEMINI_API_VERSION', 'GEMINI_USE_V1BETA'],
    'WebSocket Settings': [
      'GEMINI_WEBSOCKET_ENABLED',
      'GEMINI_TRANSCRIPTION_MODE',
      'GEMINI_WEBSOCKET_URL'
    ],
    'Reliability Settings': [
      'GEMINI_FALLBACK_TO_BATCH',
      'GEMINI_RECONNECTION_ENABLED',
      'GEMINI_MAX_RECONNECTION_ATTEMPTS'
    ],
    'Performance Settings': [
      'GEMINI_CONNECTION_TIMEOUT',
      'GEMINI_REALTIME_THRESHOLD',
      'GEMINI_RECONNECTION_DELAY'
    ],
    'Proxy Configuration': [
      'PROXY_URL',
      'PROXY_WEBSOCKET_ENABLED',
      'PROXY_FALLBACK_ENABLED',
      'PROXY_AUTH_TOKEN'
    ]
  }

  for (const [groupName, keys] of Object.entries(groups)) {
    content += `# ${groupName}\n`
    for (const key of keys) {
      if (updatedEnv[key]) {
        content += `${key}="${updatedEnv[key]}"\n`
      }
    }
    content += '\n'
  }

  // Add any other environment variables
  const handledKeys = new Set(Object.values(groups).flat())
  for (const [key, value] of Object.entries(updatedEnv)) {
    if (!handledKeys.has(key) && !key.startsWith('#')) {
      content += `${key}="${value}"\n`
    }
  }

  // Add legacy deprecation notices
  content += '\n# Legacy Variables (deprecated)\n'
  const legacyVars = [
    'GEMINI_BATCH_MODE',
    'DISABLE_WEBSOCKET',
    'USE_EXPERIMENTAL_MODEL',
    'USE_V1_ALPHA',
    'GEMINI_MODEL_VERSION'
  ]
  for (const legacyVar of legacyVars) {
    if (currentEnv[legacyVar]) {
      content += `# ${legacyVar}="${currentEnv[legacyVar]}" # DEPRECATED - migrated to v1beta settings\n`
    }
  }

  return content
}

/**
 * Perform the migration
 */
async function runMigration(options: MigrationOptions = {}): Promise<void> {
  const projectRoot = process.cwd()
  const envPath = path.join(projectRoot, '.env')
  const backupPath = path.join(projectRoot, '.env.backup')

  console.log('üöÄ Gemini Live API v1beta Configuration Migration')
  console.log('================================================\n')

  // Check if .env exists
  const currentEnv = parseExistingEnvFile(envPath)
  const hasExistingConfig = Object.keys(currentEnv).length > 0

  if (!hasExistingConfig) {
    console.log('üìù No existing .env file found. Creating optimized v1beta configuration...\n')

    // Create new optimized config
    const newEnvContent = generateUpdatedEnvContent({
      GOOGLE_API_KEY: 'your_google_api_key_here',
      GEMINI_API_KEY: 'your_google_api_key_here'
    })

    if (!options.dryRun) {
      fs.writeFileSync(envPath, newEnvContent)
      console.log('‚úÖ Created new .env file with v1beta configuration')
    } else {
      console.log('üìã Would create new .env file with:')
      console.log(newEnvContent)
    }
  } else {
    console.log('üîç Analyzing existing configuration...\n')

    // Show current configuration
    if (options.verbose) {
      console.log('Current Environment Variables:')
      Object.entries(currentEnv).forEach(([key, value]) => {
        console.log(`  ${key}=${value.length > 20 ? value.substring(0, 20) + '...' : value}`)
      })
      console.log('')
    }

    // Generate migration guide
    const legacyOptions = {
      apiKey: currentEnv.GOOGLE_API_KEY || currentEnv.GEMINI_API_KEY,
      useV1Alpha: currentEnv.USE_V1_ALPHA === 'true',
      geminiModel: currentEnv.GEMINI_MODEL_VERSION || currentEnv.GEMINI_LIVE_MODEL,
      batchMode: currentEnv.GEMINI_BATCH_MODE === 'true'
    }

    const migrationInfo = migrateToV1Beta(legacyOptions)

    console.log('üìã Migration Analysis:')
    migrationInfo.migrationSteps.forEach(step => console.log(`  ${step}`))
    console.log('')

    console.log('üéØ Benefits of v1beta Migration:')
    migrationInfo.benefits.forEach(benefit => console.log(`  ‚Ä¢ ${benefit}`))
    console.log('')

    // Create backup if requested
    if (options.backup && !options.dryRun) {
      fs.copyFileSync(envPath, backupPath)
      console.log(`üíæ Backed up existing .env to ${backupPath}`)
    }

    // Generate updated configuration
    const updatedContent = generateUpdatedEnvContent(currentEnv)

    if (!options.dryRun) {
      fs.writeFileSync(envPath, updatedContent)
      console.log('‚úÖ Updated .env file with v1beta configuration')
    } else {
      console.log('üìã Would update .env file with:')
      console.log(updatedContent)
    }
  }

  // Show final configuration summary
  if (!options.dryRun) {
    console.log('\nüìä Final Configuration Summary:')
    const finalConfig = createOptimizedV1BetaConfig()
    console.log(getConfigSummary(finalConfig))
  }

  console.log('\nüéâ Migration completed successfully!')
  console.log('\nNext steps:')
  console.log('1. Review your .env file and update the API key if needed')
  console.log('2. Test your transcription functionality')
  console.log('3. Remove any legacy environment variables from your deployment')
  console.log('\nFor more information, see the migration guide in the documentation.')
}

/**
 * CLI Interface
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2)
  const options: MigrationOptions = {}

  if (args.includes('--dry-run')) {
    options.dryRun = true
  }
  if (args.includes('--backup')) {
    options.backup = true
  }
  if (args.includes('--verbose')) {
    options.verbose = true
  }

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Gemini Live API v1beta Configuration Migration Tool

Usage: node migrate-v1beta-config.ts [options]

Options:
  --dry-run    Show what would be changed without making modifications
  --backup     Create a backup of existing .env file  
  --verbose    Show detailed information during migration
  --help       Show this help message

Examples:
  node migrate-v1beta-config.ts                    # Run migration
  node migrate-v1beta-config.ts --dry-run          # Preview changes
  node migrate-v1beta-config.ts --backup --verbose # Full migration with backup
`)
    process.exit(0)
  }

  try {
    await runMigration(options)
  } catch (error) {
    console.error('‚ùå Migration failed:', error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

// Run if called directly
if (require.main === module) {
  main()
}

export {runMigration, parseExistingEnvFile, generateUpdatedEnvContent}
