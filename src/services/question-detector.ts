/**\n * Question Detection and Classification System\n * \n * A lightweight, efficient question detection system that uses linguistic patterns,\n * semantic analysis, and machine learning techniques to identify and classify questions\n * in real-time transcribed text.\n * \n * Features:\n * - Real-time question detection with minimal latency\n * - Question type classification (factual, procedural, conversational, etc.)\n * - Context-aware analysis for complex and multi-part questions\n * - Confidence scoring for detection accuracy\n * - Extensible pattern-based and ML-based detection\n */\n\nimport {EventEmitter} from 'events'\nimport {logger} from './gemini-logger'\nimport {sanitizeLogMessage} from './log-sanitizer'\n\nexport interface QuestionDetectionConfig {\n  // Detection sensitivity\n  confidenceThreshold: number // 0.0 to 1.0, higher = more strict\n  minQuestionLength: number // minimum characters for question detection\n  maxAnalysisDelay: number // maximum ms to spend analyzing\n  \n  // Pattern matching settings\n  enablePatternMatching: boolean\n  enableSemanticAnalysis: boolean\n  enableContextAnalysis: boolean\n  \n  // Classification settings\n  enableQuestionClassification: boolean\n  classificationDepth: 'basic' | 'detailed' | 'comprehensive'\n  \n  // Performance settings\n  enableCaching: boolean\n  cacheSize: number\n  enableBatching: boolean\n  batchSize: number\n}\n\nexport interface QuestionAnalysis {\n  isQuestion: boolean\n  confidence: number\n  questionType: QuestionType\n  subType?: string\n  patterns: DetectedPattern[]\n  entities: Entity[]\n  intent: QuestionIntent\n  complexity: 'simple' | 'moderate' | 'complex'\n  requiresContext: boolean\n  timestamp: number\n}\n\nexport interface DetectedPattern {\n  type: 'interrogative' | 'auxiliary' | 'declarative_question' | 'tag_question' | 'embedded'\n  pattern: string\n  position: number\n  confidence: number\n  weight: number\n}\n\nexport interface Entity {\n  text: string\n  type: 'person' | 'organization' | 'location' | 'time' | 'number' | 'concept' | 'other'\n  position: number\n  confidence: number\n}\n\nexport interface QuestionIntent {\n  primary: 'information_seeking' | 'clarification' | 'confirmation' | 'instruction' | 'opinion'\n  secondary?: string\n  urgency: 'low' | 'medium' | 'high'\n  scope: 'specific' | 'general' | 'contextual'\n}\n\nexport type QuestionType = \n  | 'factual'        // Who, What, When, Where questions\n  | 'procedural'     // How questions  \n  | 'causal'         // Why questions\n  | 'hypothetical'   // What if questions\n  | 'comparative'    // Which, better/worse questions\n  | 'confirmatory'   // Yes/no questions\n  | 'conversational' // General dialogue questions\n  | 'complex'        // Multi-part or compound questions\n\nexport interface QuestionContext {\n  previousQuestions: string[]\n  conversationHistory: string[]\n  currentTopic?: string\n  relatedEntities: Entity[]\n  temporalContext?: {\n    timeReferences: string[]\n    sequence: number\n  }\n}\n\nexport interface DetectionMetrics {\n  totalAnalyzed: number\n  questionsDetected: number\n  averageConfidence: number\n  averageProcessingTime: number\n  patternMatchHits: number\n  semanticAnalysisHits: number\n  cacheHits: number\n  errorCount: number\n}\n\n/**\n * Question Detection and Classification Engine\n * Provides intelligent question detection with multiple analysis techniques\n */\nexport class QuestionDetector extends EventEmitter {\n  private config: QuestionDetectionConfig\n  private metrics: DetectionMetrics\n  private cache: Map<string, QuestionAnalysis>\n  private context: QuestionContext\n  private isInitialized = false\n  \n  // Pattern databases\n  private interrogativePatterns: Map<string, {weight: number, type: QuestionType}>\n  private auxiliaryPatterns: Map<string, {weight: number, type: QuestionType}>\n  private questionIndicators: Set<string>\n  private contextKeywords: Map<string, string[]>\n  \n  // Performance tracking\n  private batchQueue: string[] = []\n  private processingTimer: NodeJS.Timeout | null = null\n\n  constructor(config: Partial<QuestionDetectionConfig> = {}) {\n    super()\n    \n    this.config = {\n      confidenceThreshold: 0.7,\n      minQuestionLength: 3,\n      maxAnalysisDelay: 50, // 50ms max processing time\n      enablePatternMatching: true,\n      enableSemanticAnalysis: true,\n      enableContextAnalysis: false, // Disabled by default for performance\n      enableQuestionClassification: true,\n      classificationDepth: 'detailed',\n      enableCaching: true,\n      cacheSize: 1000,\n      enableBatching: false,\n      batchSize: 5,\n      ...config\n    }\n    \n    this.metrics = {\n      totalAnalyzed: 0,\n      questionsDetected: 0,\n      averageConfidence: 0,\n      averageProcessingTime: 0,\n      patternMatchHits: 0,\n      semanticAnalysisHits: 0,\n      cacheHits: 0,\n      errorCount: 0\n    }\n    \n    this.cache = new Map()\n    this.context = {\n      previousQuestions: [],\n      conversationHistory: [],\n      relatedEntities: []\n    }\n    \n    this.interrogativePatterns = new Map()\n    this.auxiliaryPatterns = new Map()\n    this.questionIndicators = new Set()\n    this.contextKeywords = new Map()\n    \n    logger.info('QuestionDetector initialized', {\n      confidenceThreshold: this.config.confidenceThreshold,\n      enablePatternMatching: this.config.enablePatternMatching,\n      enableSemanticAnalysis: this.config.enableSemanticAnalysis\n    })\n  }\n\n  /**\n   * Initialize the question detector\n   */\n  async initialize(): Promise<void> {\n    try {\n      if (this.isInitialized) {\n        logger.debug('QuestionDetector already initialized')\n        return\n      }\n      \n      // Initialize pattern databases\n      this.initializePatterns()\n      \n      // Initialize entity recognition patterns\n      this.initializeEntityPatterns()\n      \n      // Initialize context keywords\n      this.initializeContextKeywords()\n      \n      this.isInitialized = true\n      \n      logger.info('QuestionDetector initialization complete', {\n        interrogativePatterns: this.interrogativePatterns.size,\n        auxiliaryPatterns: this.auxiliaryPatterns.size,\n        questionIndicators: this.questionIndicators.size\n      })\n      \n      this.emit('initialized')\n    } catch (error) {\n      logger.error('Failed to initialize QuestionDetector', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      })\n      throw error\n    }\n  }\n\n  /**\n   * Detect and analyze questions in text\n   */\n  async detectQuestion(text: string, useContext = false): Promise<QuestionAnalysis | null> {\n    if (!this.isInitialized) {\n      throw new Error('QuestionDetector must be initialized before use')\n    }\n    \n    if (!text || text.trim().length < this.config.minQuestionLength) {\n      return null\n    }\n    \n    const startTime = performance.now()\n    \n    try {\n      // Check cache first\n      const cacheKey = this.generateCacheKey(text)\n      if (this.config.enableCaching && this.cache.has(cacheKey)) {\n        this.metrics.cacheHits++\n        const cachedResult = this.cache.get(cacheKey)!\n        this.updateMetrics(performance.now() - startTime, cachedResult.confidence)\n        return cachedResult\n      }\n      \n      // Analyze the text\n      const analysis = await this.analyzeText(text, useContext)\n      \n      // Cache the result\n      if (this.config.enableCaching && analysis) {\n        this.cacheResult(cacheKey, analysis)\n      }\n      \n      // Update metrics\n      this.updateMetrics(performance.now() - startTime, analysis?.confidence || 0)\n      \n      // Update context if question detected\n      if (analysis && analysis.isQuestion) {\n        this.updateContext(text, analysis)\n      }\n      \n      this.emit('question_analyzed', {\n        text,\n        analysis,\n        processingTime: performance.now() - startTime\n      })\n      \n      return analysis\n      \n    } catch (error) {\n      this.metrics.errorCount++\n      logger.error('Error detecting question', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        text: sanitizeLogMessage(text)\n      })\n      return null\n    }\n  }\n\n  /**\n   * Batch process multiple texts\n   */\n  async detectQuestionsBatch(texts: string[]): Promise<(QuestionAnalysis | null)[]> {\n    if (!this.config.enableBatching) {\n      // Process individually if batching disabled\n      return Promise.all(texts.map(text => this.detectQuestion(text)))\n    }\n    \n    const results: (QuestionAnalysis | null)[] = []\n    \n    for (let i = 0; i < texts.length; i += this.config.batchSize) {\n      const batch = texts.slice(i, i + this.config.batchSize)\n      const batchResults = await Promise.all(\n        batch.map(text => this.detectQuestion(text))\n      )\n      results.push(...batchResults)\n    }\n    \n    return results\n  }\n\n  /**\n   * Main text analysis function\n   */\n  private async analyzeText(text: string, useContext: boolean): Promise<QuestionAnalysis | null> {\n    const cleanText = this.preprocessText(text)\n    const patterns: DetectedPattern[] = []\n    const entities: Entity[] = []\n    \n    let confidence = 0\n    let questionType: QuestionType = 'conversational'\n    let isQuestion = false\n    \n    // 1. Pattern-based detection\n    if (this.config.enablePatternMatching) {\n      const patternResults = this.detectPatterns(cleanText)\n      patterns.push(...patternResults.patterns)\n      confidence = Math.max(confidence, patternResults.confidence)\n      \n      if (patternResults.confidence > this.config.confidenceThreshold) {\n        isQuestion = true\n        questionType = patternResults.type\n        this.metrics.patternMatchHits++\n      }\n    }\n    \n    // 2. Semantic analysis\n    if (this.config.enableSemanticAnalysis) {\n      const semanticResults = this.performSemanticAnalysis(cleanText)\n      confidence = Math.max(confidence, semanticResults.confidence)\n      entities.push(...semanticResults.entities)\n      \n      if (semanticResults.confidence > this.config.confidenceThreshold) {\n        isQuestion = true\n        if (semanticResults.type !== 'conversational') {\n          questionType = semanticResults.type\n        }\n        this.metrics.semanticAnalysisHits++\n      }\n    }\n    \n    // 3. Context analysis (if enabled and requested)\n    if (this.config.enableContextAnalysis && useContext) {\n      const contextResults = this.analyzeContext(cleanText)\n      confidence = Math.max(confidence, contextResults.confidence)\n      \n      if (contextResults.isQuestion) {\n        isQuestion = true\n      }\n    }\n    \n    // Determine final classification\n    if (!isQuestion || confidence < this.config.confidenceThreshold) {\n      return null\n    }\n    \n    const analysis: QuestionAnalysis = {\n      isQuestion,\n      confidence,\n      questionType,\n      patterns,\n      entities,\n      intent: this.determineIntent(cleanText, questionType, entities),\n      complexity: this.determineComplexity(cleanText, patterns, entities),\n      requiresContext: this.requiresContext(cleanText, questionType),\n      timestamp: Date.now()\n    }\n    \n    // Add detailed classification if enabled\n    if (this.config.enableQuestionClassification && this.config.classificationDepth !== 'basic') {\n      analysis.subType = this.classifyQuestionSubtype(cleanText, questionType, entities)\n    }\n    \n    this.metrics.questionsDetected++\n    \n    return analysis\n  }\n\n  /**\n   * Detect linguistic patterns in text\n   */\n  private detectPatterns(text: string): {\n    patterns: DetectedPattern[]\n    confidence: number\n    type: QuestionType\n  } {\n    const patterns: DetectedPattern[] = []\n    let maxConfidence = 0\n    let dominantType: QuestionType = 'conversational'\n    \n    const words = text.toLowerCase().split(/\\s+/)\n    const firstWord = words[0]\n    const lastChar = text.trim().slice(-1)\n    \n    // 1. Check for question mark (strongest indicator)\n    if (lastChar === '?') {\n      patterns.push({\n        type: 'interrogative',\n        pattern: '?',\n        position: text.length - 1,\n        confidence: 0.95,\n        weight: 1.0\n      })\n      maxConfidence = Math.max(maxConfidence, 0.95)\n    }\n    \n    // 2. Check interrogative words (who, what, when, where, why, how)\n    for (const [pattern, info] of this.interrogativePatterns.entries()) {\n      if (firstWord === pattern.toLowerCase()) {\n        patterns.push({\n          type: 'interrogative',\n          pattern,\n          position: 0,\n          confidence: 0.9 * info.weight,\n          weight: info.weight\n        })\n        maxConfidence = Math.max(maxConfidence, 0.9 * info.weight)\n        dominantType = info.type\n      }\n    }\n    \n    // 3. Check auxiliary verb patterns (do, does, did, can, could, will, would, etc.)\n    for (const [pattern, info] of this.auxiliaryPatterns.entries()) {\n      if (firstWord === pattern.toLowerCase()) {\n        patterns.push({\n          type: 'auxiliary',\n          pattern,\n          position: 0,\n          confidence: 0.85 * info.weight,\n          weight: info.weight\n        })\n        maxConfidence = Math.max(maxConfidence, 0.85 * info.weight)\n        if (dominantType === 'conversational') {\n          dominantType = info.type\n        }\n      }\n    }\n    \n    // 4. Check for tag questions (\"isn't it?\", \"don't you?\", \"right?\", etc.)\n    const tagQuestionPattern = /\\b(isn't|aren't|don't|doesn't|didn't|won't|wouldn't|can't|couldn't|right|correct)\\s*(it|you|they|that|this)\\?*\\s*$/i\n    if (tagQuestionPattern.test(text)) {\n      patterns.push({\n        type: 'tag_question',\n        pattern: 'tag_question',\n        position: text.search(tagQuestionPattern),\n        confidence: 0.8,\n        weight: 0.8\n      })\n      maxConfidence = Math.max(maxConfidence, 0.8)\n      dominantType = 'confirmatory'\n    }\n    \n    // 5. Check for embedded questions\n    const embeddedPatterns = [\n      /\\b(tell me|explain|clarify|help me understand)\\b/i,\n      /\\b(I wonder|I'm wondering|wondering)\\b/i,\n      /\\b(curious about|interested in knowing)\\b/i\n    ]\n    \n    embeddedPatterns.forEach((pattern, index) => {\n      const match = text.match(pattern)\n      if (match) {\n        patterns.push({\n          type: 'embedded',\n          pattern: match[0],\n          position: match.index || 0,\n          confidence: 0.7,\n          weight: 0.6\n        })\n        maxConfidence = Math.max(maxConfidence, 0.7)\n        if (dominantType === 'conversational') {\n          dominantType = 'factual'\n        }\n      }\n    })\n    \n    return {\n      patterns,\n      confidence: maxConfidence,\n      type: dominantType\n    }\n  }\n\n  /**\n   * Perform semantic analysis of text\n   */\n  private performSemanticAnalysis(text: string): {\n    confidence: number\n    type: QuestionType\n    entities: Entity[]\n  } {\n    const entities = this.extractEntities(text)\n    const words = text.toLowerCase().split(/\\s+/)\n    \n    let confidence = 0\n    let type: QuestionType = 'conversational'\n    \n    // Analyze for information-seeking patterns\n    const informationSeeking = [\n      'information', 'details', 'facts', 'data', 'statistics',\n      'explain', 'describe', 'define', 'meaning', 'definition'\n    ]\n    \n    const proceduralKeywords = [\n      'how', 'steps', 'process', 'procedure', 'method', 'way',\n      'instructions', 'tutorial', 'guide'\n    ]\n    \n    const causalKeywords = [\n      'why', 'because', 'reason', 'cause', 'purpose', 'motivation'\n    ]\n    \n    const comparativeKeywords = [\n      'better', 'worse', 'compare', 'versus', 'difference', 'similar',\n      'which', 'best', 'worst', 'prefer'\n    ]\n    \n    // Calculate semantic confidence based on keyword presence\n    let keywordMatches = 0\n    \n    if (informationSeeking.some(keyword => text.toLowerCase().includes(keyword))) {\n      keywordMatches++\n      type = 'factual'\n    }\n    \n    if (proceduralKeywords.some(keyword => text.toLowerCase().includes(keyword))) {\n      keywordMatches++\n      type = 'procedural'\n    }\n    \n    if (causalKeywords.some(keyword => text.toLowerCase().includes(keyword))) {\n      keywordMatches++\n      type = 'causal'\n    }\n    \n    if (comparativeKeywords.some(keyword => text.toLowerCase().includes(keyword))) {\n      keywordMatches++\n      type = 'comparative'\n    }\n    \n    // Base confidence on keyword matches and sentence structure\n    confidence = Math.min(0.8, keywordMatches * 0.2 + entities.length * 0.1)\n    \n    // Boost confidence if entities suggest information seeking\n    if (entities.some(entity => ['person', 'organization', 'location', 'time'].includes(entity.type))) {\n      confidence += 0.2\n    }\n    \n    return {\n      confidence: Math.min(confidence, 1.0),\n      type,\n      entities\n    }\n  }\n\n  /**\n   * Extract entities from text\n   */\n  private extractEntities(text: string): Entity[] {\n    const entities: Entity[] = []\n    \n    // Simple entity recognition patterns\n    const patterns = {\n      person: /\\b([A-Z][a-z]+ [A-Z][a-z]+)\\b/g, // Simple name pattern\n      time: /\\b(\\d{1,2}:\\d{2}|\\d{1,2}\\s*(am|pm)|today|tomorrow|yesterday|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/gi,\n      number: /\\b\\d+(\\.\\d+)?\\b/g,\n      location: /\\b(in|at|from|to)\\s+([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\b/g\n    }\n    \n    Object.entries(patterns).forEach(([type, pattern]) => {\n      let match\n      while ((match = pattern.exec(text)) !== null) {\n        entities.push({\n          text: match[0],\n          type: type as Entity['type'],\n          position: match.index,\n          confidence: 0.7\n        })\n      }\n    })\n    \n    return entities\n  }\n\n  /**\n   * Analyze context for additional question indicators\n   */\n  private analyzeContext(text: string): {\n    confidence: number\n    isQuestion: boolean\n  } {\n    // Simple context analysis based on conversation history\n    const recentQuestions = this.context.previousQuestions.slice(-3)\n    \n    let confidence = 0\n    let isQuestion = false\n    \n    // Check if this follows a pattern of questions\n    if (recentQuestions.length >= 2) {\n      confidence += 0.1\n    }\n    \n    // Check for follow-up patterns\n    const followUpPatterns = [\n      /\\b(also|additionally|furthermore|moreover)\\b/i,\n      /\\b(and|but|however|though)\\b/i,\n      /\\b(follow.up|continue|more)\\b/i\n    ]\n    \n    if (followUpPatterns.some(pattern => pattern.test(text))) {\n      confidence += 0.2\n      isQuestion = confidence > 0.5\n    }\n    \n    return { confidence, isQuestion }\n  }\n\n  /**\n   * Determine question intent\n   */\n  private determineIntent(text: string, type: QuestionType, entities: Entity[]): QuestionIntent {\n    const words = text.toLowerCase()\n    \n    // Determine primary intent\n    let primary: QuestionIntent['primary'] = 'information_seeking'\n    \n    if (['confirmatory'].includes(type) || words.includes('right') || words.includes('correct')) {\n      primary = 'confirmation'\n    } else if (words.includes('how') && (words.includes('do') || words.includes('make'))) {\n      primary = 'instruction'\n    } else if (['what do you think', 'opinion', 'believe', 'feel'].some(phrase => words.includes(phrase))) {\n      primary = 'opinion'\n    } else if (['explain', 'clarify', 'mean'].some(word => words.includes(word))) {\n      primary = 'clarification'\n    }\n    \n    // Determine urgency\n    let urgency: QuestionIntent['urgency'] = 'medium'\n    \n    if (['urgent', 'quickly', 'now', 'immediately'].some(word => words.includes(word))) {\n      urgency = 'high'\n    } else if (['sometime', 'when you can', 'no rush'].some(phrase => words.includes(phrase))) {\n      urgency = 'low'\n    }\n    \n    // Determine scope\n    let scope: QuestionIntent['scope'] = 'general'\n    \n    if (entities.length > 0 || ['specific', 'exactly', 'precisely'].some(word => words.includes(word))) {\n      scope = 'specific'\n    } else if (['context', 'situation', 'case', 'regarding'].some(word => words.includes(word))) {\n      scope = 'contextual'\n    }\n    \n    return { primary, urgency, scope }\n  }\n\n  /**\n   * Determine question complexity\n   */\n  private determineComplexity(text: string, patterns: DetectedPattern[], entities: Entity[]): 'simple' | 'moderate' | 'complex' {\n    const words = text.split(/\\s+/).length\n    const sentences = text.split(/[.!?]+/).length\n    const conjunctions = (text.match(/\\b(and|or|but|however|moreover|furthermore|additionally)\\b/gi) || []).length\n    \n    let complexity: 'simple' | 'moderate' | 'complex' = 'simple'\n    \n    // Simple complexity scoring\n    let score = 0\n    \n    if (words > 15) score += 1\n    if (sentences > 1) score += 1\n    if (conjunctions > 0) score += conjunctions\n    if (entities.length > 2) score += 1\n    if (patterns.length > 2) score += 1\n    \n    if (score >= 4) {\n      complexity = 'complex'\n    } else if (score >= 2) {\n      complexity = 'moderate'\n    }\n    \n    return complexity\n  }\n\n  /**\n   * Determine if question requires context\n   */\n  private requiresContext(text: string, type: QuestionType): boolean {\n    const contextIndicators = [\n      'this', 'that', 'it', 'they', 'them', 'here', 'there',\n      'above', 'below', 'previous', 'earlier', 'mentioned'\n    ]\n    \n    const hasContextIndicators = contextIndicators.some(indicator => \n      text.toLowerCase().includes(indicator)\n    )\n    \n    return hasContextIndicators || ['comparative', 'complex'].includes(type)\n  }\n\n  /**\n   * Classify question subtype\n   */\n  private classifyQuestionSubtype(text: string, type: QuestionType, entities: Entity[]): string {\n    const words = text.toLowerCase()\n    \n    switch (type) {\n      case 'factual':\n        if (entities.some(e => e.type === 'person')) return 'biographical'\n        if (entities.some(e => e.type === 'location')) return 'geographical'\n        if (entities.some(e => e.type === 'time')) return 'temporal'\n        if (entities.some(e => e.type === 'number')) return 'quantitative'\n        return 'general_factual'\n        \n      case 'procedural':\n        if (words.includes('install') || words.includes('setup')) return 'installation'\n        if (words.includes('fix') || words.includes('repair')) return 'troubleshooting'\n        if (words.includes('make') || words.includes('create')) return 'creation'\n        return 'general_procedural'\n        \n      case 'causal':\n        if (words.includes('happen') || words.includes('occur')) return 'event_causation'\n        if (words.includes('work') || words.includes('function')) return 'functional_causation'\n        return 'general_causation'\n        \n      case 'comparative':\n        if (words.includes('better') || words.includes('best')) return 'qualitative_comparison'\n        if (words.includes('difference')) return 'differential_comparison'\n        return 'general_comparison'\n        \n      default:\n        return 'standard'\n    }\n  }\n\n  /**\n   * Preprocess text for analysis\n   */\n  private preprocessText(text: string): string {\n    return text\n      .trim()\n      .replace(/\\s+/g, ' ') // normalize whitespace\n      .replace(/[^\\w\\s?!.,;:]/g, '') // remove special characters except basic punctuation\n  }\n\n  /**\n   * Update context with new question\n   */\n  private updateContext(text: string, analysis: QuestionAnalysis): void {\n    this.context.previousQuestions.push(text)\n    \n    // Keep only last 10 questions for context\n    if (this.context.previousQuestions.length > 10) {\n      this.context.previousQuestions = this.context.previousQuestions.slice(-10)\n    }\n    \n    // Update related entities\n    analysis.entities.forEach(entity => {\n      const existing = this.context.relatedEntities.find(e => \n        e.text === entity.text && e.type === entity.type\n      )\n      if (!existing) {\n        this.context.relatedEntities.push(entity)\n      }\n    })\n    \n    // Keep only last 50 entities\n    if (this.context.relatedEntities.length > 50) {\n      this.context.relatedEntities = this.context.relatedEntities.slice(-50)\n    }\n  }\n\n  /**\n   * Generate cache key\n   */\n  private generateCacheKey(text: string): string {\n    return Buffer.from(text.toLowerCase().trim()).toString('base64').slice(0, 32)\n  }\n\n  /**\n   * Cache analysis result\n   */\n  private cacheResult(key: string, analysis: QuestionAnalysis): void {\n    if (this.cache.size >= this.config.cacheSize) {\n      // Remove oldest entries\n      const oldestKeys = Array.from(this.cache.keys()).slice(0, this.config.cacheSize * 0.2)\n      oldestKeys.forEach(k => this.cache.delete(k))\n    }\n    \n    this.cache.set(key, analysis)\n  }\n\n  /**\n   * Update performance metrics\n   */\n  private updateMetrics(processingTime: number, confidence: number): void {\n    this.metrics.totalAnalyzed++\n    \n    // Update averages using running average\n    const alpha = 0.1 // smoothing factor\n    this.metrics.averageProcessingTime = alpha * processingTime + (1 - alpha) * this.metrics.averageProcessingTime\n    this.metrics.averageConfidence = alpha * confidence + (1 - alpha) * this.metrics.averageConfidence\n  }\n\n  /**\n   * Initialize linguistic patterns\n   */\n  private initializePatterns(): void {\n    // Interrogative words with weights and types\n    const interrogatives = [\n      { pattern: 'who', weight: 1.0, type: 'factual' as QuestionType },\n      { pattern: 'what', weight: 1.0, type: 'factual' as QuestionType },\n      { pattern: 'when', weight: 1.0, type: 'factual' as QuestionType },\n      { pattern: 'where', weight: 1.0, type: 'factual' as QuestionType },\n      { pattern: 'why', weight: 1.0, type: 'causal' as QuestionType },\n      { pattern: 'how', weight: 1.0, type: 'procedural' as QuestionType },\n      { pattern: 'which', weight: 0.9, type: 'comparative' as QuestionType },\n      { pattern: 'whose', weight: 0.8, type: 'factual' as QuestionType },\n      { pattern: 'whom', weight: 0.7, type: 'factual' as QuestionType }\n    ]\n    \n    interrogatives.forEach(({ pattern, weight, type }) => {\n      this.interrogativePatterns.set(pattern, { weight, type })\n    })\n    \n    // Auxiliary verbs with weights and types\n    const auxiliaries = [\n      { pattern: 'do', weight: 0.8, type: 'confirmatory' as QuestionType },\n      { pattern: 'does', weight: 0.8, type: 'confirmatory' as QuestionType },\n      { pattern: 'did', weight: 0.8, type: 'confirmatory' as QuestionType },\n      { pattern: 'can', weight: 0.9, type: 'confirmatory' as QuestionType },\n      { pattern: 'could', weight: 0.9, type: 'hypothetical' as QuestionType },\n      { pattern: 'will', weight: 0.8, type: 'confirmatory' as QuestionType },\n      { pattern: 'would', weight: 0.9, type: 'hypothetical' as QuestionType },\n      { pattern: 'should', weight: 0.8, type: 'confirmatory' as QuestionType },\n      { pattern: 'is', weight: 0.7, type: 'confirmatory' as QuestionType },\n      { pattern: 'are', weight: 0.7, type: 'confirmatory' as QuestionType },\n      { pattern: 'was', weight: 0.7, type: 'confirmatory' as QuestionType },\n      { pattern: 'were', weight: 0.7, type: 'confirmatory' as QuestionType },\n      { pattern: 'have', weight: 0.6, type: 'confirmatory' as QuestionType },\n      { pattern: 'has', weight: 0.6, type: 'confirmatory' as QuestionType },\n      { pattern: 'had', weight: 0.6, type: 'confirmatory' as QuestionType }\n    ]\n    \n    auxiliaries.forEach(({ pattern, weight, type }) => {\n      this.auxiliaryPatterns.set(pattern, { weight, type })\n    })\n    \n    // Question indicators\n    const indicators = [\n      'tell me', 'explain', 'describe', 'clarify', 'help',\n      'wondering', 'curious', 'confused', 'unsure',\n      'question', 'ask', 'inquiry', 'wonder'\n    ]\n    \n    indicators.forEach(indicator => {\n      this.questionIndicators.add(indicator)\n    })\n  }\n\n  /**\n   * Initialize entity recognition patterns\n   */\n  private initializeEntityPatterns(): void {\n    // This would be expanded with more sophisticated entity recognition\n    // For now, we rely on the simple patterns in extractEntities\n  }\n\n  /**\n   * Initialize context keywords\n   */\n  private initializeContextKeywords(): void {\n    this.contextKeywords.set('technology', ['software', 'hardware', 'computer', 'internet', 'app', 'program'])\n    this.contextKeywords.set('science', ['research', 'study', 'experiment', 'theory', 'data', 'analysis'])\n    this.contextKeywords.set('business', ['company', 'organization', 'market', 'sales', 'revenue', 'profit'])\n    this.contextKeywords.set('health', ['medical', 'doctor', 'hospital', 'medicine', 'treatment', 'disease'])\n    this.contextKeywords.set('education', ['school', 'university', 'student', 'teacher', 'learning', 'study'])\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<QuestionDetectionConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // Clear cache if cache settings changed\n    if (newConfig.cacheSize !== undefined || newConfig.enableCaching !== undefined) {\n      this.cache.clear()\n    }\n    \n    logger.info('QuestionDetector configuration updated', {\n      confidenceThreshold: this.config.confidenceThreshold,\n      enableCaching: this.config.enableCaching\n    })\n    \n    this.emit('config_updated', this.config)\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): DetectionMetrics {\n    return { ...this.metrics }\n  }\n\n  /**\n   * Get current context\n   */\n  getContext(): QuestionContext {\n    return {\n      previousQuestions: [...this.context.previousQuestions],\n      conversationHistory: [...this.context.conversationHistory],\n      currentTopic: this.context.currentTopic,\n      relatedEntities: [...this.context.relatedEntities],\n      temporalContext: this.context.temporalContext\n    }\n  }\n\n  /**\n   * Clear context\n   */\n  clearContext(): void {\n    this.context.previousQuestions = []\n    this.context.conversationHistory = []\n    this.context.currentTopic = undefined\n    this.context.relatedEntities = []\n    this.context.temporalContext = undefined\n    \n    logger.info('QuestionDetector context cleared')\n    this.emit('context_cleared')\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear()\n    this.metrics.cacheHits = 0\n    \n    logger.info('QuestionDetector cache cleared')\n    this.emit('cache_cleared')\n  }\n\n  /**\n   * Export analysis data\n   */\n  exportAnalysisData(): {\n    config: QuestionDetectionConfig\n    metrics: DetectionMetrics\n    context: QuestionContext\n  } {\n    return {\n      config: this.config,\n      metrics: this.getMetrics(),\n      context: this.getContext()\n    }\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    if (this.processingTimer) {\n      clearTimeout(this.processingTimer)\n      this.processingTimer = null\n    }\n    \n    this.cache.clear()\n    this.clearContext()\n    this.removeAllListeners()\n    this.isInitialized = false\n    \n    logger.info('QuestionDetector destroyed')\n  }\n}\n\nexport default QuestionDetector