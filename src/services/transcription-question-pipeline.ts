/**\n * Transcription Question Pipeline\n * \n * Integration layer that connects the QuestionDetector with the Gemini Live WebSocket\n * transcription pipeline. Provides real-time question detection from streaming transcription\n * data and triggers appropriate responses for the AI answering machine system.\n * \n * Features:\n * - Real-time transcription monitoring and question detection\n * - Intelligent buffering for partial transcription analysis\n * - Context-aware question classification with conversation history\n * - Performance-optimized processing with configurable thresholds\n * - Event-driven architecture for seamless integration\n * - Comprehensive metrics and monitoring\n */\n\nimport {EventEmitter} from 'events'\nimport {QuestionDetector, QuestionAnalysis, QuestionDetectionConfig} from './question-detector'\nimport {GeminiLiveWebSocketClient} from './gemini-live-websocket'\nimport {logger} from './gemini-logger'\nimport {sanitizeLogMessage} from './log-sanitizer'\n\nexport interface TranscriptionPipelineConfig {\n  // Question detection settings\n  questionDetection: Partial<QuestionDetectionConfig>\n  \n  // Transcription processing settings\n  processPartialTranscripts: boolean\n  bufferTimeMs: number // How long to buffer partial transcripts before analysis\n  minTextLengthForAnalysis: number\n  \n  // Performance settings\n  maxProcessingDelayMs: number\n  enableBatchProcessing: boolean\n  batchSizeThreshold: number\n  \n  // Context management\n  enableConversationContext: boolean\n  maxContextHistoryItems: number\n  contextExpiryMs: number\n  \n  // Quality control\n  minConfidenceForQuestionTrigger: number\n  requireFinalTranscriptConfirmation: boolean\n  duplicateQuestionTimeoutMs: number\n}\n\nexport interface TranscriptionEvent {\n  text: string\n  confidence: number\n  isFinal: boolean\n  source?: string\n  duration?: number\n  timestamp: number\n}\n\nexport interface QuestionEvent {\n  originalText: string\n  analysis: QuestionAnalysis\n  transcriptionEvent: TranscriptionEvent\n  processingTimeMs: number\n  source: 'partial' | 'final' | 'synthesized'\n}\n\nexport interface PipelineMetrics {\n  transcriptsProcessed: number\n  questionsDetected: number\n  partialTranscriptsAnalyzed: number\n  finalTranscriptsAnalyzed: number\n  averageProcessingTimeMs: number\n  bufferFlushCount: number\n  duplicatesFiltered: number\n  contextHits: number\n  errorCount: number\n  uptime: number\n}\n\nexport interface BufferedTranscript {\n  text: string\n  confidence: number\n  receivedAt: number\n  source?: string\n  processed: boolean\n}\n\n/**\n * Transcription Question Pipeline\n * Bridges real-time transcription with intelligent question detection\n */\nexport class TranscriptionQuestionPipeline extends EventEmitter {\n  private config: TranscriptionPipelineConfig\n  private questionDetector: QuestionDetector\n  private webSocketClient: GeminiLiveWebSocketClient | null = null\n  \n  // Buffering and processing\n  private partialBuffer: BufferedTranscript[] = []\n  private bufferTimer: NodeJS.Timeout | null = null\n  private lastQuestionText: string | null = null\n  private lastQuestionTime: number = 0\n  \n  // Context and history\n  private conversationHistory: TranscriptionEvent[] = []\n  private recentQuestions: QuestionEvent[] = []\n  \n  // Metrics and monitoring\n  private metrics: PipelineMetrics\n  private startTime: number\n  private isInitialized = false\n  private isActive = false\n\n  constructor(config: Partial<TranscriptionPipelineConfig> = {}) {\n    super()\n    \n    this.config = {\n      questionDetection: {\n        confidenceThreshold: 0.75,\n        enablePatternMatching: true,\n        enableSemanticAnalysis: true,\n        enableContextAnalysis: true,\n        enableQuestionClassification: true,\n        classificationDepth: 'detailed',\n        enableCaching: true,\n        cacheSize: 500\n      },\n      processPartialTranscripts: true,\n      bufferTimeMs: 1000, // 1 second buffer for partial transcripts\n      minTextLengthForAnalysis: 5,\n      maxProcessingDelayMs: 100,\n      enableBatchProcessing: false,\n      batchSizeThreshold: 3,\n      enableConversationContext: true,\n      maxContextHistoryItems: 50,\n      contextExpiryMs: 300000, // 5 minutes\n      minConfidenceForQuestionTrigger: 0.7,\n      requireFinalTranscriptConfirmation: false,\n      duplicateQuestionTimeoutMs: 5000, // 5 seconds\n      ...config\n    }\n    \n    this.questionDetector = new QuestionDetector(this.config.questionDetection)\n    \n    this.metrics = {\n      transcriptsProcessed: 0,\n      questionsDetected: 0,\n      partialTranscriptsAnalyzed: 0,\n      finalTranscriptsAnalyzed: 0,\n      averageProcessingTimeMs: 0,\n      bufferFlushCount: 0,\n      duplicatesFiltered: 0,\n      contextHits: 0,\n      errorCount: 0,\n      uptime: 0\n    }\n    \n    this.startTime = Date.now()\n    \n    logger.info('TranscriptionQuestionPipeline initialized', {\n      processPartialTranscripts: this.config.processPartialTranscripts,\n      bufferTimeMs: this.config.bufferTimeMs,\n      enableConversationContext: this.config.enableConversationContext\n    })\n  }\n\n  /**\n   * Initialize the pipeline\n   */\n  async initialize(): Promise<void> {\n    try {\n      if (this.isInitialized) {\n        logger.debug('TranscriptionQuestionPipeline already initialized')\n        return\n      }\n      \n      // Initialize question detector\n      await this.questionDetector.initialize()\n      \n      // Set up question detector event listeners\n      this.questionDetector.on('question_analyzed', (data) => {\n        this.emit('detector_analysis', data)\n      })\n      \n      this.questionDetector.on('config_updated', (config) => {\n        logger.debug('QuestionDetector configuration updated', config)\n      })\n      \n      this.isInitialized = true\n      \n      logger.info('TranscriptionQuestionPipeline initialization complete')\n      this.emit('initialized')\n      \n    } catch (error) {\n      logger.error('Failed to initialize TranscriptionQuestionPipeline', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      })\n      throw error\n    }\n  }\n\n  /**\n   * Connect to Gemini Live WebSocket client\n   */\n  connectToWebSocket(client: GeminiLiveWebSocketClient): void {\n    if (!this.isInitialized) {\n      throw new Error('Pipeline must be initialized before connecting to WebSocket')\n    }\n    \n    this.webSocketClient = client\n    \n    // Listen for transcription events\n    client.on('transcriptionUpdate', (data: {\n      text: string\n      confidence: number\n      isFinal: boolean\n    }) => {\n      this.handleTranscriptionUpdate({\n        text: data.text,\n        confidence: data.confidence,\n        isFinal: data.isFinal,\n        timestamp: Date.now()\n      })\n    })\n    \n    client.on('transcription', (data: {\n      text: string\n      confidence: number\n      duration?: number\n      source?: string\n    }) => {\n      this.handleTranscriptionUpdate({\n        text: data.text,\n        confidence: data.confidence,\n        isFinal: true,\n        source: data.source,\n        duration: data.duration,\n        timestamp: Date.now()\n      })\n    })\n    \n    // Handle WebSocket disconnection\n    client.on('disconnected', () => {\n      this.handleDisconnection()\n    })\n    \n    // Handle WebSocket errors\n    client.on('error', (error) => {\n      this.handleWebSocketError(error)\n    })\n    \n    this.isActive = true\n    \n    logger.info('TranscriptionQuestionPipeline connected to WebSocket client')\n    this.emit('websocket_connected')\n  }\n\n  /**\n   * Disconnect from WebSocket client\n   */\n  disconnectFromWebSocket(): void {\n    if (this.webSocketClient) {\n      // Remove listeners to prevent memory leaks\n      this.webSocketClient.removeAllListeners('transcriptionUpdate')\n      this.webSocketClient.removeAllListeners('transcription')\n      this.webSocketClient.removeAllListeners('disconnected')\n      this.webSocketClient.removeAllListeners('error')\n      \n      this.webSocketClient = null\n    }\n    \n    this.isActive = false\n    \n    // Process any remaining buffered transcripts\n    this.flushBuffer()\n    \n    logger.info('TranscriptionQuestionPipeline disconnected from WebSocket client')\n    this.emit('websocket_disconnected')\n  }\n\n  /**\n   * Handle incoming transcription updates\n   */\n  private async handleTranscriptionUpdate(event: TranscriptionEvent): Promise<void> {\n    try {\n      this.metrics.transcriptsProcessed++\n      \n      // Add to conversation history if context is enabled\n      if (this.config.enableConversationContext) {\n        this.addToConversationHistory(event)\n      }\n      \n      // Determine processing path based on transcript finality\n      if (event.isFinal) {\n        await this.processFinalTranscript(event)\n      } else if (this.config.processPartialTranscripts) {\n        this.bufferPartialTranscript(event)\n      }\n      \n      this.emit('transcription_received', event)\n      \n    } catch (error) {\n      this.metrics.errorCount++\n      logger.error('Error handling transcription update', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        textLength: event.text.length,\n        isFinal: event.isFinal\n      })\n    }\n  }\n\n  /**\n   * Process final transcription for question detection\n   */\n  private async processFinalTranscript(event: TranscriptionEvent): Promise<void> {\n    const startTime = performance.now()\n    \n    try {\n      // Skip if text is too short\n      if (event.text.trim().length < this.config.minTextLengthForAnalysis) {\n        return\n      }\n      \n      // Check for duplicate questions\n      if (this.isDuplicateQuestion(event.text)) {\n        this.metrics.duplicatesFiltered++\n        return\n      }\n      \n      // Perform question detection\n      const analysis = await this.questionDetector.detectQuestion(\n        event.text,\n        this.config.enableConversationContext\n      )\n      \n      this.metrics.finalTranscriptsAnalyzed++\n      \n      // Check if we detected a question with sufficient confidence\n      if (analysis && \n          analysis.isQuestion && \n          analysis.confidence >= this.config.minConfidenceForQuestionTrigger) {\n        \n        const processingTime = performance.now() - startTime\n        \n        const questionEvent: QuestionEvent = {\n          originalText: event.text,\n          analysis,\n          transcriptionEvent: event,\n          processingTimeMs: processingTime,\n          source: 'final'\n        }\n        \n        await this.processQuestionDetection(questionEvent)\n      }\n      \n    } catch (error) {\n      this.metrics.errorCount++\n      logger.error('Error processing final transcript', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        text: sanitizeLogMessage(event.text)\n      })\n    }\n  }\n\n  /**\n   * Buffer partial transcript for delayed processing\n   */\n  private bufferPartialTranscript(event: TranscriptionEvent): void {\n    // Skip very short partial transcripts\n    if (event.text.trim().length < this.config.minTextLengthForAnalysis) {\n      return\n    }\n    \n    const bufferedTranscript: BufferedTranscript = {\n      text: event.text,\n      confidence: event.confidence,\n      receivedAt: event.timestamp,\n      source: event.source,\n      processed: false\n    }\n    \n    this.partialBuffer.push(bufferedTranscript)\n    \n    // Set up buffer flush timer if not already running\n    if (!this.bufferTimer) {\n      this.bufferTimer = setTimeout(() => {\n        this.flushBuffer()\n      }, this.config.bufferTimeMs)\n    }\n    \n    // Force flush if buffer gets too large\n    if (this.partialBuffer.length >= this.config.batchSizeThreshold * 2) {\n      this.flushBuffer()\n    }\n  }\n\n  /**\n   * Process buffered partial transcripts\n   */\n  private async flushBuffer(): Promise<void> {\n    if (this.bufferTimer) {\n      clearTimeout(this.bufferTimer)\n      this.bufferTimer = null\n    }\n    \n    if (this.partialBuffer.length === 0) {\n      return\n    }\n    \n    const startTime = performance.now()\n    this.metrics.bufferFlushCount++\n    \n    try {\n      // Get the most recent unprocessed transcript from the buffer\n      const recentTranscripts = this.partialBuffer\n        .filter(t => !t.processed)\n        .slice(-3) // Take last 3 for context\n      \n      if (recentTranscripts.length === 0) {\n        this.partialBuffer = []\n        return\n      }\n      \n      // Use the most recent transcript as primary analysis target\n      const primaryTranscript = recentTranscripts[recentTranscripts.length - 1]\n      \n      // Combine recent transcripts for context if enabled\n      let textToAnalyze = primaryTranscript.text\n      \n      if (this.config.enableConversationContext && recentTranscripts.length > 1) {\n        // Create contextual text from recent transcripts\n        const contextualText = recentTranscripts\n          .map(t => t.text)\n          .join(' ')\n          .trim()\n        \n        if (contextualText.length > textToAnalyze.length) {\n          textToAnalyze = contextualText\n          this.metrics.contextHits++\n        }\n      }\n      \n      // Skip analysis if text is too short or duplicate\n      if (textToAnalyze.length < this.config.minTextLengthForAnalysis ||\n          this.isDuplicateQuestion(textToAnalyze)) {\n        this.partialBuffer = []\n        return\n      }\n      \n      // Perform question detection on buffered content\n      const analysis = await this.questionDetector.detectQuestion(\n        textToAnalyze,\n        this.config.enableConversationContext\n      )\n      \n      this.metrics.partialTranscriptsAnalyzed++\n      \n      // Process question if detected with sufficient confidence\n      if (analysis && \n          analysis.isQuestion && \n          analysis.confidence >= this.config.minConfidenceForQuestionTrigger) {\n        \n        const processingTime = performance.now() - startTime\n        \n        // Create synthetic transcription event for the buffered analysis\n        const syntheticEvent: TranscriptionEvent = {\n          text: textToAnalyze,\n          confidence: Math.max(...recentTranscripts.map(t => t.confidence)),\n          isFinal: false,\n          source: 'buffered_partial',\n          timestamp: primaryTranscript.receivedAt\n        }\n        \n        const questionEvent: QuestionEvent = {\n          originalText: textToAnalyze,\n          analysis,\n          transcriptionEvent: syntheticEvent,\n          processingTimeMs: processingTime,\n          source: 'partial'\n        }\n        \n        await this.processQuestionDetection(questionEvent)\n      }\n      \n      // Clear processed buffer\n      this.partialBuffer = []\n      \n    } catch (error) {\n      this.metrics.errorCount++\n      logger.error('Error flushing transcription buffer', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        bufferSize: this.partialBuffer.length\n      })\n      \n      // Clear buffer on error to prevent infinite retry\n      this.partialBuffer = []\n    }\n  }\n\n  /**\n   * Process detected question event\n   */\n  private async processQuestionDetection(questionEvent: QuestionEvent): Promise<void> {\n    try {\n      this.metrics.questionsDetected++\n      \n      // Update last question tracking\n      this.lastQuestionText = questionEvent.originalText\n      this.lastQuestionTime = Date.now()\n      \n      // Add to recent questions history\n      this.recentQuestions.push(questionEvent)\n      \n      // Limit recent questions history size\n      if (this.recentQuestions.length > 10) {\n        this.recentQuestions = this.recentQuestions.slice(-10)\n      }\n      \n      // Update processing time metrics\n      this.updateProcessingMetrics(questionEvent.processingTimeMs)\n      \n      logger.info('Question detected in transcription', {\n        questionType: questionEvent.analysis.questionType,\n        confidence: questionEvent.analysis.confidence,\n        complexity: questionEvent.analysis.complexity,\n        processingTime: questionEvent.processingTimeMs,\n        source: questionEvent.source,\n        textLength: questionEvent.originalText.length\n      })\n      \n      // Emit the question detection event for other services to handle\n      this.emit('question_detected', questionEvent)\n      \n      // Emit specific events for different question types\n      this.emit(`question_${questionEvent.analysis.questionType}`, questionEvent)\n      \n      // Emit priority event if the question requires urgent processing\n      if (questionEvent.analysis.intent.urgency === 'high') {\n        this.emit('urgent_question_detected', questionEvent)\n      }\n      \n    } catch (error) {\n      this.metrics.errorCount++\n      logger.error('Error processing question detection', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        questionType: questionEvent.analysis.questionType\n      })\n    }\n  }\n\n  /**\n   * Check if question is a duplicate based on recent history\n   */\n  private isDuplicateQuestion(text: string): boolean {\n    const now = Date.now()\n    const normalizedText = text.toLowerCase().trim()\n    \n    // Check against last question within timeout window\n    if (this.lastQuestionText && \n        this.lastQuestionTime && \n        (now - this.lastQuestionTime) < this.config.duplicateQuestionTimeoutMs) {\n      \n      const lastNormalized = this.lastQuestionText.toLowerCase().trim()\n      \n      // Use simple similarity check (could be enhanced with edit distance)\n      const similarity = this.calculateTextSimilarity(normalizedText, lastNormalized)\n      \n      if (similarity > 0.8) {\n        return true\n      }\n    }\n    \n    return false\n  }\n\n  /**\n   * Calculate text similarity (simple implementation)\n   */\n  private calculateTextSimilarity(text1: string, text2: string): number {\n    if (text1 === text2) return 1.0\n    \n    const words1 = new Set(text1.split(/\\s+/))\n    const words2 = new Set(text2.split(/\\s+/))\n    \n    const intersection = new Set([...words1].filter(word => words2.has(word)))\n    const union = new Set([...words1, ...words2])\n    \n    return intersection.size / union.size\n  }\n\n  /**\n   * Add transcription to conversation history\n   */\n  private addToConversationHistory(event: TranscriptionEvent): void {\n    this.conversationHistory.push(event)\n    \n    // Remove expired entries\n    const now = Date.now()\n    this.conversationHistory = this.conversationHistory.filter(\n      entry => (now - entry.timestamp) < this.config.contextExpiryMs\n    )\n    \n    // Limit history size\n    if (this.conversationHistory.length > this.config.maxContextHistoryItems) {\n      this.conversationHistory = this.conversationHistory.slice(-this.config.maxContextHistoryItems)\n    }\n  }\n\n  /**\n   * Update processing time metrics\n   */\n  private updateProcessingMetrics(processingTime: number): void {\n    // Use exponential moving average for processing time\n    const alpha = 0.1\n    this.metrics.averageProcessingTimeMs = \n      alpha * processingTime + (1 - alpha) * this.metrics.averageProcessingTimeMs\n  }\n\n  /**\n   * Handle WebSocket disconnection\n   */\n  private handleDisconnection(): void {\n    this.isActive = false\n    this.flushBuffer() // Process any remaining buffered content\n    \n    logger.warn('WebSocket disconnected, pipeline deactivated')\n    this.emit('pipeline_deactivated')\n  }\n\n  /**\n   * Handle WebSocket errors\n   */\n  private handleWebSocketError(error: any): void {\n    this.metrics.errorCount++\n    logger.error('WebSocket error in transcription pipeline', {\n      error: error instanceof Error ? error.message : 'Unknown error'\n    })\n    \n    this.emit('websocket_error', error)\n  }\n\n  /**\n   * Update pipeline configuration\n   */\n  updateConfiguration(newConfig: Partial<TranscriptionPipelineConfig>): void {\n    const oldConfig = { ...this.config }\n    this.config = { ...this.config, ...newConfig }\n    \n    // Update question detector config if needed\n    if (newConfig.questionDetection) {\n      this.questionDetector.updateConfig(newConfig.questionDetection)\n    }\n    \n    logger.info('TranscriptionQuestionPipeline configuration updated', {\n      changes: this.getConfigChanges(oldConfig, this.config)\n    })\n    \n    this.emit('config_updated', this.config)\n  }\n\n  /**\n   * Get configuration changes summary\n   */\n  private getConfigChanges(oldConfig: any, newConfig: any): string[] {\n    const changes: string[] = []\n    \n    Object.keys(newConfig).forEach(key => {\n      if (key !== 'questionDetection' && oldConfig[key] !== newConfig[key]) {\n        changes.push(`${key}: ${oldConfig[key]} -> ${newConfig[key]}`)\n      }\n    })\n    \n    return changes\n  }\n\n  /**\n   * Get current pipeline metrics\n   */\n  getMetrics(): PipelineMetrics {\n    return {\n      ...this.metrics,\n      uptime: Date.now() - this.startTime\n    }\n  }\n\n  /**\n   * Get conversation history\n   */\n  getConversationHistory(): TranscriptionEvent[] {\n    return [...this.conversationHistory]\n  }\n\n  /**\n   * Get recent questions\n   */\n  getRecentQuestions(): QuestionEvent[] {\n    return [...this.recentQuestions]\n  }\n\n  /**\n   * Get pipeline status\n   */\n  getStatus(): {\n    isInitialized: boolean\n    isActive: boolean\n    isConnected: boolean\n    bufferSize: number\n    metrics: PipelineMetrics\n  } {\n    return {\n      isInitialized: this.isInitialized,\n      isActive: this.isActive,\n      isConnected: this.webSocketClient !== null,\n      bufferSize: this.partialBuffer.length,\n      metrics: this.getMetrics()\n    }\n  }\n\n  /**\n   * Clear all context and history\n   */\n  clearContext(): void {\n    this.conversationHistory = []\n    this.recentQuestions = []\n    this.partialBuffer = []\n    this.lastQuestionText = null\n    this.lastQuestionTime = 0\n    \n    // Clear question detector context\n    this.questionDetector.clearContext()\n    \n    logger.info('TranscriptionQuestionPipeline context cleared')\n    this.emit('context_cleared')\n  }\n\n  /**\n   * Reset metrics\n   */\n  resetMetrics(): void {\n    this.metrics = {\n      transcriptsProcessed: 0,\n      questionsDetected: 0,\n      partialTranscriptsAnalyzed: 0,\n      finalTranscriptsAnalyzed: 0,\n      averageProcessingTimeMs: 0,\n      bufferFlushCount: 0,\n      duplicatesFiltered: 0,\n      contextHits: 0,\n      errorCount: 0,\n      uptime: 0\n    }\n    \n    this.startTime = Date.now()\n    \n    logger.info('TranscriptionQuestionPipeline metrics reset')\n    this.emit('metrics_reset')\n  }\n\n  /**\n   * Destroy and cleanup\n   */\n  destroy(): void {\n    // Clear timers\n    if (this.bufferTimer) {\n      clearTimeout(this.bufferTimer)\n      this.bufferTimer = null\n    }\n    \n    // Disconnect from WebSocket\n    this.disconnectFromWebSocket()\n    \n    // Destroy question detector\n    this.questionDetector.destroy()\n    \n    // Clear all data\n    this.clearContext()\n    \n    // Remove all listeners\n    this.removeAllListeners()\n    \n    this.isInitialized = false\n    this.isActive = false\n    \n    logger.info('TranscriptionQuestionPipeline destroyed')\n  }\n}\n\nexport default TranscriptionQuestionPipeline