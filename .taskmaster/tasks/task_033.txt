# Task ID: 33
# Title: Implement WebSocket Turn Completion Signaling for Gemini Live API
# Status: pending
# Dependencies: 13, 15, 16, 20, 22
# Priority: high
# Description: Implement proper turn completion signaling for the Gemini Live API WebSocket connection to enable transcription responses, addressing the current issue where audio is sent but no responses are received.
# Details:
1. Implement `sendTurnCompletion()` method in GeminiLiveWebSocketClient:
   ```typescript
   public sendTurnCompletion(): Promise<void> {
     if (!this.isConnected) {
       throw new Error('Cannot send turn completion: WebSocket not connected');
     }
     
     const turnCompletionMessage = {
       clientContent: {
         turnCompletion: {}
       }
     };
     
     return this.sendMessage(turnCompletionMessage);
   }
   ```

2. Update the audio streaming sequence to properly signal turn completion:
   ```typescript
   async function streamAudioAndSignalCompletion(audioData: Uint8Array): Promise<void> {
     try {
       // Send audio data
       await wsClient.sendAudioData(audioData);
       
       // Signal end of audio stream
       await wsClient.sendAudioStreamEnd();
       
       // Send turn completion signal to trigger processing
       await wsClient.sendTurnCompletion();
       
       console.log('Turn completion signal sent successfully');
     } catch (error) {
       console.error('Error in audio streaming sequence:', error);
       throw error;
     }
   }
   ```

3. Update message format to use clientContent structure for turn management:
   ```typescript
   interface ClientMessage {
     clientContent?: {
       audio?: {
         content: string; // base64 encoded audio
       };
       audioStreamEnd?: {};
       turnCompletion?: {};
     };
   }
   ```

4. Modify the system instruction to work in conversational mode:
   ```typescript
   function createSetupMessage(config: GeminiSetupConfig): SetupMessage {
     return {
       setup: {
         model: config.model || "models/gemini-2.0-flash-live-001",
         generationConfig: {
           responseModalities: ["TEXT"],
           conversationMode: true // Enable conversational mode
         }
       }
     };
   }
   ```

5. Add proper error handling for turn completion failures:
   ```typescript
   private handleTurnCompletionError(error: Error): void {
     console.error('Turn completion failed:', error);
     this.emit('turnCompletionError', error);
     
     // Attempt recovery if connection is still active
     if (this.isConnected && this.autoRecovery) {
       console.log('Attempting to recover from turn completion failure');
       this.resetConversationState();
     }
   }
   ```

6. Implement a timeout mechanism for turn completion responses:
   ```typescript
   private setTurnCompletionTimeout(): void {
     if (this.turnCompletionTimeout) {
       clearTimeout(this.turnCompletionTimeout);
     }
     
     this.turnCompletionTimeout = setTimeout(() => {
       const error = new Error('Turn completion response timeout');
       this.handleTurnCompletionError(error);
     }, this.config.turnCompletionTimeoutMs || 10000);
   }
   ```

7. Update the WebSocket message handler to process transcription responses:
   ```typescript
   private handleWebSocketMessage(event: MessageEvent): void {
     try {
       const response = JSON.parse(event.data);
       
       if (response.modelResponse?.content?.parts) {
         // Clear turn completion timeout
         if (this.turnCompletionTimeout) {
           clearTimeout(this.turnCompletionTimeout);
         }
         
         // Process transcription response
         const transcription = this.extractTranscriptionFromResponse(response);
         this.emit('transcription', transcription);
       }
     } catch (error) {
       console.error('Error processing WebSocket message:', error);
     }
   }
   ```

8. Ensure proper sequencing in the main transcription flow:
   ```typescript
   async function performTranscription(audioStream: ReadableStream): Promise<void> {
     const wsClient = new GeminiLiveWebSocketClient(config);
     
     try {
       await wsClient.connect();
       
       // Process audio chunks
       for await (const chunk of audioStream) {
         await wsClient.sendAudioData(chunk);
       }
       
       // Signal end of audio stream
       await wsClient.sendAudioStreamEnd();
       
       // Send turn completion to trigger processing
       await wsClient.sendTurnCompletion();
     } catch (error) {
       console.error('Transcription error:', error);
     } finally {
       await wsClient.disconnect();
     }
   }
   ```

# Test Strategy:
1. Unit Testing:
   a. Create unit tests for the sendTurnCompletion() method:
      - Test successful turn completion signal sending
      - Test error handling when WebSocket is not connected
      - Verify proper message structure for turn completion
   
   b. Test the audio streaming sequence:
      - Verify correct ordering: audio → audioStreamEnd → turnCompletion
      - Test error handling during each step of the sequence
      - Validate event emissions during the sequence

2. Integration Testing:
   a. Set up a test environment with the Gemini Live API:
      - Create a test script that establishes WebSocket connection
      - Send audio data followed by turn completion signal
      - Verify transcription responses are received
   
   b. Test error scenarios:
      - Test recovery from connection interruptions
      - Verify timeout handling for unresponsive API
      - Test behavior with malformed turn completion messages

3. End-to-End Testing:
   a. Implement a complete transcription flow test:
      - Record or use pre-recorded audio samples
      - Process through the entire pipeline including turn completion
      - Verify transcription results match expected output
   
   b. Performance testing:
      - Measure latency between turn completion signal and first response
      - Test with various audio lengths and complexities
      - Verify system stability during extended usage

4. Manual Testing:
   a. Use the application UI to test the transcription flow:
      - Speak into the microphone and verify real-time transcription
      - Test with different speaking patterns and pauses
      - Verify the UI correctly shows when processing is occurring

5. Regression Testing:
   a. Ensure existing functionality remains intact:
      - Verify all WebSocket client methods still work correctly
      - Test compatibility with other components that use the WebSocket client
      - Confirm no performance degradation in the overall system

# Subtasks:
## 1. Implement sendTurnCompletion() method [pending]
### Dependencies: None
### Description: Implement the sendTurnCompletion() method in GeminiLiveWebSocketClient class to signal the end of user input and trigger model processing
### Details:
Add a new method that sends a proper turn completion message to the Gemini Live API. The message should follow the clientContent structure with end_of_turn flag. This is critical for getting transcription responses.

## 2. Update transcription flow to use turn completion [pending]
### Dependencies: 33.1
### Description: Update main-stt-transcription.ts to call sendTurnCompletion() after audio transmission completes
### Details:
Modify the transcription flow to call the new turn completion method after sending all audio chunks and the audioStreamEnd signal. This tells the API that the user's turn is complete and it should process the audio.

## 3. Update system instruction for conversational mode [pending]
### Dependencies: 33.2
### Description: Update system instruction to work in conversational mode rather than transcription-only mode
### Details:
Change the system instruction from transcription-only mode to a conversational approach that responds to audio with text. The current instruction may be preventing responses since the API expects conversational interaction.

